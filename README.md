### 1.3
Дан набор целых чисел с четным количеством элементов. Заполнить вектор V исходными
числами, вывести вначале вторую половину элементов вектора V, а затем первую половину (в
каждой половине порядок элементов не изменять).

#### Алгоритм решения 
1. Объявить переменную n для количества элементов.
2. Ввести n, проверяя, чтобы оно было четным. Если нечетное — запросить ввод заново.
3. Создать вектор vec длиной n.
4. Заполнить вектор, вводя элементы с клавиатуры.
5. Вывести сначала вторую половину элементов (от n/2 до n-1).
6. Затем вывести первую половину элементов (от 0 до n/2 - 1).
7. Завершить программу.

#### Тестирование
<img width="389" height="97" alt="image" src="https://github.com/user-attachments/assets/88810d47-a09c-497f-8f37-d0d5466cafd6" />


### 2.7
Дан вектор V. Вставить после каждого элемента исходного вектора число − 1. Использовать
функцию-член insert в цикле с параметром-итератором.
Указание. Организуйте перебор элементов вектора в цикле с параметром-итератором i.
Вставку выполняйте впозицию ++i, обязательно присваивая параметру i значение,
возвращаемое функцией-членом insert.

#### Алгоритм решения 
1. Ввести число n — размер вектора.  
2. Создать вектор из n элементов.  
3. Ввести n чисел и записать их в вектор.  
4. Пройти по вектору с шагом 2, начиная со второго элемента.  
5. После каждого исходного элемента вставить число 1.  
6. Вывести полученный вектор на экран.  
7. Завершить выполнение программы.

#### Тестирование
<img width="206" height="115" alt="image" src="https://github.com/user-attachments/assets/47f4f3c7-4f58-4ade-863b-c313e58773b2" />


### 3.5
Даны списки L1 и L2; список L1 имеет нечетное количество элементов. Переместить средний
элемент списка L1 в конец списка L2. Использовать один вызов функции-члена splice.


#### Алгоритм решения 
1. Ввести нечетный размер первого списка size1, проверяя корректность.
2. Ввести размер второго списка size2.
3. Ввести элементы списка L1.
4. Ввести элементы списка L2.
5. Найти итератор на средний элемент L1 (позиция size1/2).
6. Одним вызовом функции splice переместить средний элемент из L1 в конец L2.
7. Вывести изменённые списки L1 и L2.

#### Тестирование
<img width="337" height="94" alt="image" src="https://github.com/user-attachments/assets/fa68e31a-bf1b-4e07-a416-c05093ceb77f" />


### 4.7
Дана строка name и целое число K (> 0). Записать в текстовый файл с именем name K символов
«*». Использовать алгоритм fill_n.

#### Алгоритм решения 
1. Запросить у пользователя число K (>0), проверить правильность ввода.  
2. Открыть файл для записи.  
3. Если файл открыт, записать в него K символов '*'.  
4. Вывести сообщение об успешной записи или ошибке.  
5. Завершить.

#### Тестирование
<img width="296" height="37" alt="image" src="https://github.com/user-attachments/assets/a407a07f-e29a-4a80-b015-f5a0ba2c5d43" />
<img width="52" height="15" alt="image" src="https://github.com/user-attachments/assets/5a403e8a-ed09-481e-a9f2-ba6f4b67c243" />


### 5.2
Дан дек D. Удалить последний нулевой элемент дека. Если нулевых элементов нет, то дек не
изменять. Использовать алгоритм find с обратными итераторами и функцию-член erase.
Указание. Алгоритм find может возвращать обратный итератор, однако функция-член erase не
позволяет его использовать для удаления элемента. Необходимо перейти от обратного
итератора r к связанному с ним обычному итератору, используя функцию-член обратного
итератора r.base(). При этом следует учитывать, что функция r.base() возвращает итератор,
связанный с элементом, следующим за тем, с которым связан обратный итератор r. Поэтому в
функции-члене erase следует указать одно из следующих выражений (предполагается, что r —
это обратный итератор, который вернул алгоритм find, и этот итератор отличен от rend): --
r.base() или (++r).base().

#### Алгоритм решения 
1. Создать дек D = { 1, 0, 2, 0, 3 }.  
2. Найти с конца первый элемент, равный 0.  
3. Удалить найденный элемент.  
4. Вывести все элементы дека.

#### Тестирование
<img width="72" height="20" alt="image" src="https://github.com/user-attachments/assets/3c7c2d79-f54f-4520-9fd6-b79f5fc2853f" />


### 6.11
Дан список L с четным количеством элементов. Скопировать в конец списка все элементы,
расположенные в его первой половине, заменив при этом отрицательные элементы на нули и
расположив скопированные элементы в обратном порядке. Использовать алгоритм
replace_copy_if, итератор вставки и обратные итераторы, а также функцию advance

#### Алгоритм решения 
1. Создать вектор L с элементами {5, -1, 2, -7, 8, 3}.  
2. Вычислить позицию середины mid с помощью advance.  
3. Создать обратные итераторы, начиная с mid и конца вектора.  
4. Использовать replace_copy_if для замены отрицательных элементов, найденных в обратном порядке, на 0, добавляя новые элементы в конец вектора.  
5. Вывести итоговый вектор.  

#### Тестирование
<img width="161" height="18" alt="image" src="https://github.com/user-attachments/assets/e30dc4b9-4d11-4c84-8d72-c950f405cb09" />


### 7.8
Дан список L с четным количеством элементов. Перегруппировать элементы списка,
расположив в нем вначале все четные элементы из первой половины исходного списка, затем
все нечетные элементы, а затем — все четные элементы из второй половины списка (порядок
расположения элементов в каждой группе должен совпадать с исходным). Использовать два
вызова алгоритма stable_partition.

#### Алгоритм решения 
1. Создать вектор L с элементами {3, 4, 6, 7, 5, 8, 10, 11}.  
2. Определить середину mid.  
3. В первой половине выполнить stable_partition, чтобы четные шли вначале.  
4. Во второй половине выполнить stable_partition, чтобы четные шли вначале.  
5. Вывести полученный вектор.

#### Тестирование
<img width="142" height="17" alt="image" src="https://github.com/user-attachments/assets/a33f6407-a78f-4b5a-b348-a269f0a9a88e" />


### 8.2
Дан список L, элементами которого являются английские слова. Получить дек D со строковыми
элементами, каждый из которых строится по паре соседних элементов исходного списка L
следующим образом: последняя буква правого элемента пары приписывается справа к первой
букве левого элемента пары. Количество элементов дека D должно быть на 1 меньше
количества элементов списка L. Например, для исходного списка ABC, DEF, KLM, XYZ
полученный дек должен содержать строки AF, DM, KZ. Использовать алгоритм
adjacent_difference с итератором вставки и функциональным объектом, а также функцию-член
erase для дека D.

#### Алгоритм решения 
1. Создать вектор строк L.  
2. Создать пустую деку D.  
3. Использовать adjacent_difference с лямбда-функцией для обработки пар соседних элементов L, добавляя результат в D.  
4. Удалить первый элемент из D.  
5. Вывести оставшиеся элементы D.

#### Тестирование
<img width="72" height="15" alt="image" src="https://github.com/user-attachments/assets/bac14f69-3600-4f89-b51c-df04fcb51445" />


### 9.2
Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0
не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N,
в которых содержатся все элементы вектора V0 (с учетом их повторений). Использовать
алгоритм includes, применяя его в цикле к двум мультимножествам (контейнерам типа
multiset), одно из которых создано на основе вектора V0, а другое на очередной итерации
содержит элементы очередного из векторов VI, I = 1, …, N.

#### Алгоритм решения 
1. Создать исходный вектор V0.  
2. Создать несколько векторов vectors.  
3. Преобразовать V0 в мультимножество msV0.  
4. Итеративно преобразовать каждый вектор из vectors в мультимножество msVI.  
5. Проверить, содержит ли msVI все элементы из msV0 с помощью std::includes.  
6. Подсчитать количество таких векторов.  
7. Вывести результат.

#### Тестирование
<img width="407" height="22" alt="image" src="https://github.com/user-attachments/assets/362fa926-3026-4ee9-83ab-371729d93f1d" />


### 10.3
Дан вектор V. Выполнить группировку элементов вектора V, используя в качестве ключа
группировки последнюю (т. е. правую) цифру элемента: в одну группу должны входить все
элементы вектора V, оканчивающиеся на одну и ту же цифру (сгруппированные элементы
должны располагаться в том же порядке, в котором они располагались в исходном векторе).
Представить результат группировки в виде мультиотображения M (класса multimap), ключами
которого являются ключи группировки, т. е. последние цифры элементов вектора V, а
значениями — элементы вектора, оканчивающиеся на соответствующую цифру (таким
образом, отображение M должно иметь тип multimap<int, int>). Вывести полученное
отображение (для каждого элемента отображения M вначале выводить ключ, а затем
связанный с ним элемент вектора V; ключи могут повторяться). Для перебора элементов
контейнеров использовать циклы с параметрами-итераторами.

#### Алгоритм решения 
1. Создать вектор целых чисел V.  
2. Создать пустой мультимап M.  
3. Для каждого элемента из V вычислить ключ как остаток от деления на 10.  
4. Вставить пару (ключ, значение) в мультимап M.  
5. Вывести все пары ключ-значение из мультимапы.

#### Тестирование
<img width="185" height="136" alt="image" src="https://github.com/user-attachments/assets/671c1f6f-808f-4e3d-bff6-11e2fae6ffcf" />


